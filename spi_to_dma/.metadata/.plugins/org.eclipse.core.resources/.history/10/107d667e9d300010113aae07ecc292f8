/******************************************************************************
 * @Title		:	Tasks
 * @Filename	:	tasks.c
 * @Author		:	Derek Murray
 * @Origin Date	:	15/05/2020
 * @Version		:	1.0.0
 * @Compiler	:	arm-none-eabi-gcc
 * @Target		: 	Xilinx Zynq-7000
 * @Platform	: 	Digilent Zybo-Z7-20
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (C) 2021  Derek Murray
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
******************************************************************************/



/*****************************************************************************/
/***************************** Include Files *********************************/
/*****************************************************************************/

#include "tasks.h"

#include "dma/dma.h"
/*****************************************************************************/
/************************** Variable Declarations ****************************/
/*****************************************************************************/

/* Use to slow down LED toggle rates, when loop rate is very fast */
static volatile uint32_t led1_count = 0;
static volatile uint32_t led2_count = 0;
static volatile uint32_t task_3_count = 0;




/*****************************************************************************
 * Function: task1()
 *//**
 *
 * @brief		Simple task to toggle LED1. The led1_count variable is needed
 * 				to slow down the toggle rate when the code is running at a
 * 				very fast rate, as in that case, the LED might appear to be
 * 				always on.
 *
 * @return		None.
 *
 * @note		None.
 *
******************************************************************************/

void task1(u32 *destination, u32 DESTINATION_LENGTH){
	int Status;
	static int dma_counter = 0;

	//u8 *RxBufferPtr;
	//RxBufferPtr = (u8 *)RX_BUFFER_BASE;
	psGpOutSet(PS_GP_OUT3);		/// TEST SIGNAL



	/*
	 * Wait for RX done or timeout
	 */
	Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &RxDone);
	if (Status != XST_SUCCESS) {
		//xil_printf("no RXDone event registered:  %d\r\n", Status);
		goto Done;
	}

	//Xil_DCacheFlushRange((UINTPTR)RxBufferPtr, MAX_PKT_LEN);
	xil_printf("RXDone event registered!\r\n");
	/* Invalidate the DestBuffer before receiving the data, in case the
	 * Data Cache is enabled
	 */
	Xil_DCacheInvalidateRange((UINTPTR)destination, MAX_PKT_LEN);
	//dma_counter++;
	//int offset = dma_counter * MAX_PKT_LEN;

	//if ((offset+MAX_PKT_LEN)<= DESTINATION_LENGTH){
	//int DMAstatus = DMAStart(destination + offset);
	//} else {
	//	xil_printf("receive buffer filled, no more DMA transfer started!\r\n");
	//	DMADone = 1;
	//}

	RxDone = 0;

	/* Disable TX and RX Ring interrupts and return success */
	//DisableIntrSystem(&Intc, RX_INTR_ID);

Done:
	//return;
	//xil_printf("--- Exiting task1 --- \r\n");


	/* Dummy delay for test purposes */
	uint32_t idx = 0;
	//for (idx = 0; idx <= 50; idx++) {
	//	psGpOutSet(PS_GP_OUT3);		/// TEST SIGNAL
	//}

	//xil_printf("n\r\n");

	//psGpOutClear(PS_GP_OUT3);	/// TEST SIGNAL
}




/*****************************************************************************
 * Function: task2()
 *//**
 *
 * @brief		Simple task to toggle LED2. The led2_count variable is needed
 * 				to slow down the toggle rate when the code is running at a
 * 				very fast rate, as in that case, the LED might appear to be
 * 				always on.
 *
 * @return		None.
 *
 * @note		None.
 *
******************************************************************************/

void task2(void){

	psGpOutSet(PS_GP_OUT4);		/// TEST SIGNAL

	led2_count++;

	if (led2_count >= LED2_TOGGLE_COUNT)
	{
		axiGpOutToggle(LED2);
		led2_count = 0;
	}

	/* Dummy delay for test purposes */
	uint32_t idx = 0;
	for (idx = 0; idx <= 80; idx++) {
		psGpOutSet(PS_GP_OUT4);		/// TEST SIGNAL
	}

	psGpOutClear(PS_GP_OUT4);	/// TEST SIGNAL
}



/*****************************************************************************
 * Function: task3()
 *//**
 *
 * @brief		Write out a small portion of the data on the serial port.
 * 				always on.
 *
 * @return		None.
 *
 * @note		None.
 *
******************************************************************************/

void task3(u32 *global_destination, u32 DESTINATION_LENGTH){
	static int task_3_count = 0;
	if (task_3_count <= 1 && DMADone){
		task_3_count++;
		int MEASUREMENTS = DESTINATION_LENGTH/6;
		for(int i = 0;i<=MEASUREMENTS; i++){

			u8 refidx3 = global_destination[i*6];
			u8 refidx2 = global_destination[i*6 +1];
			u8 refidx1 = global_destination[i*6 + 2];

			u8 stopresult3 = global_destination[i*6 + 3];
			u8 stopresult2 = global_destination[i*6 + 4];
			u8 stopresult1 = global_destination[i*6 + 5];

			uint32_t refidx = (refidx3 << 16) | (refidx2 << 8) | refidx1;
			uint32_t stopresult = (stopresult3 << 16) | (stopresult2 << 8) | stopresult1;


			xil_printf("refindex:  %d\r\n", refidx);
			xil_printf("stopresult:  %d\r\n", stopresult);

		}
		//TODO
	}
}


/****** End functions *****/

/****** End of File **********************************************************/
