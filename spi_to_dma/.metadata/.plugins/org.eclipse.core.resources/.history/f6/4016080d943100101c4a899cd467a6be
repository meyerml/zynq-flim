/******************************************************************************
 * @Title		:	GPX2 Interface
 * @Filename	:	gpx2_if.c
 * @Author		:	Derek Murray
 * @Origin Date	:	15/05/2020
 * @Version		:	1.0.0
 * @Compiler	:	arm-none-eabi-gcc
 * @Target		: 	Xilinx Zynq-7000
 * @Platform	: 	Digilent Zybo-Z7-20
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (C) 2021  Derek Murray
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
******************************************************************************/





/*****************************************************************************/
/***************************** Include Files *********************************/
/*****************************************************************************/

#include "gpx2_if.h"


/*****************************************************************************/
/************************** Constant Definitions *****************************/
/*****************************************************************************/



/*****************************************************************************/
/******************************* Typedefs ************************************/
/*****************************************************************************/



/*****************************************************************************/
/************************** Variable Declarations ****************************/
/*****************************************************************************/


/****************************************************************************/
/***************** Macros (Inline Functions) Definitions ********************/
/****************************************************************************/



/*****************************************************************************/
/************************** Function Prototypes ******************************/
/*****************************************************************************/




/*---------------------------------------------------------------------------*/
/*------------------------------- FUNCTIONS ---------------------------------*/
/*---------------------------------------------------------------------------*/


/*****************************************************************************
 * Function: gpx2_Init()
 *//**
 *
 * @brief		Initialises the PmodACL accelerometer.
 *
 *
 * @details		Calls the axi_spiInit() function to initialise the
 * 				AXI SPI	block. If the AXI SPI initialisation is successful, then
 * 				configures the PmodACL with the desired values for this project.
 *
 * @return		Integer indicating result of configuration attempt.
 * 				0 = SUCCESS, 1 = FAILURE
 * @note
 *
****************************************************************************/

int gpx2_Init()
{
	//TODO: update initialization according to new hardware.
	//then switch to the new spi master.
	//detect interrupt,
	//handle spi comm and dma storage in task
	//
	// the default registers as recommended in the GPX2 data sheets example code:
	//

	//turn off lvds output for spi read
	uint8_t GPX2_STARTUP_CONFIG[17] = {0x11, 0x01, 0x1F, 0x40, 0x0D, 0x03, 0xC0,
			0x53, 0xA1, 0x13, 0x00, 0x0A, 0xCC, 0xCC, 0x31, 0x8E, 0x04 };	//uint8_t GPX2_STARTUP_CONFIG[17] = {0x31, 0x01, 0x1F, 0x40, 0x0D, 0x03, 0xC0,
	//		0x53, 0xA1, 0x13, 0x00, 0x0A, 0xCC, 0xCC, 0x31, 0x8E, 0x04 };
	//uint8_t GPX2_STARTUP_CONFIG[17] = {0x31, 0x01, 0x1F, 0x40, 0x0D, 0x03, 0xC0,
	//		0x53, 0xA1, 0x13, 0x00, 0x0A, 0xCC, 0xCC, 0x31, 0x8E, 0x04 };

	uint8_t configReadBack[17] = {0};
	/* Set SPI options for the PMOD_ACL.
	 * Parameters can be found in xspi.h.
	uint32_t options = XSP_CLK_ACTIVE_LOW_OPTION
						| XSP_MANUAL_SSELECT_OPTION
						| XSP_CLK_PHASE_1_OPTION
						| XSP_MASTER_OPTION;
	*/
	/* Set SPI options for the GPX2 to work in SPI mode 1.
	 * Parameters can be found in xspi.h. */
	uint32_t options =  XSP_MANUAL_SSELECT_OPTION
						| XSP_CLK_PHASE_1_OPTION
						| XSP_MASTER_OPTION;

	/* Initialise the AXI SPI block */
	int status;
	status = axi_spiInit(options);


	/* If AXI SPI initialisation is successful, configure
	 * the PmodACL with desired values for this project. */
	//TODO: update with meaningful GPX2 register values
	if (status == XST_SUCCESS)
	{
		//disableInterrupts();
	    uint8_t command = POR_CMD;

		spiWriteBytes(&command,1); //restart the gpx2 device


		gpx2_WriteBytesContinuously(0x00, &GPX2_STARTUP_CONFIG ,17);

		gpx2_ReadBytesContinuously(0x00, &configReadBack,17);
		//enableInterrupts();
		for (uint8_t b = 0; b<17; b++){
			if(configReadBack[b] != GPX2_STARTUP_CONFIG[b]){
				status = XST_FAILURE;
			}
		}


		//start the gpx2 measurement by sending the start command
		uint8_t command = INIT_START_CMD;
		spiWriteBytes(&command,1);
		//toggle mux towards the custom spi interface
		axiGpOutSet(SPI_SEL_1);
		//axiSpiSelectOutSet(SPI_SELECT_1);
		/*
		gpx2_WriteByte(THRESH_TAP_REG, THRESH_TAP_VAL);
		gpx2_WriteByte(DUR_REG, DUR_VAL);
		gpx2_WriteByte(THRESH_INACT_REG, THRESH_INACT_VAL);
		gpx2_WriteByte(TIME_INACT_REG, TIME_INACT_VAL);
		gpx2_WriteByte(ACT_INACT_CTL_REG, ACT_INACT_CTL_VAL);
		gpx2_WriteByte(TAP_AXES_REG, TAP_AXES_VAL);
		gpx2_WriteByte(BW_RATE_REG, BW_RATE_VAL);
		gpx2_WriteByte(POWER_CTL_REG, POWER_CTL_VAL);
		gpx2_WriteByte(INT_ENABLE_REG, INT_ENABLE_VAL);
		gpx2_WriteByte(INT_MAP_REG, INT_MAP_VAL);
		gpx2_WriteByte(DATA_FORMAT_REG, DATA_FORMAT_VAL);
		*/
	}
	// else just end

	return status;

}



/*****************************************************************************
 * Function: gpx2_ReadByte()
 *//**
 *
 * @brief		Reads a single register of the GPX2.
 *
 * @return		Register read data, single byte (uint8_t).
 *
 * @param[in]	PmodACL register address to read from.
 *
 * @note
 *
****************************************************************************/

uint8_t gpx2_ReadByte(uint8_t reg_addr)
{

	uint8_t nbytes = 2U;
	uint8_t *read_data;

	/* Data to put on SPI bus */
	uint8_t tx_data[2] = {(reg_addr |= 0x40), 0U};

	/* Set nbytes = 2U; one byte for addr, and one for return data */
	read_data =  spiReadBytes(tx_data, nbytes);

	/* Byte 1 is the read data */
	return read_data[1];
}


/*****************************************************************************
 * Function: gpx2_ReadBytesContinuously()
 *//**
 *
 * @brief		Reads a single or multiple consecutive registers of the GPX2.
 *
 * @return		Register read data, single byte (uint8_t).
 *
 * @param[in]	PmodACL register address to read from.
 *
 * @note
 *
****************************************************************************/

void gpx2_ReadBytesContinuously(uint8_t reg_addr, uint8_t* read_data, uint8_t nbytes)
{
    /* Data to put on SPI bus */
    uint8_t tx_data[nbytes + 1];


    /* Set the first byte to the register address with the MSB set */
    tx_data[0] = reg_addr | 0x40;

    /* Copy the write_data into tx_data */
    for (uint8_t i = 0; i < nbytes; i++) {
        tx_data[i + 1] = 0x00;
    }

    /* Read data into a temporary buffer */
    uint8_t* temp_buffer = spiReadBytes(&tx_data, nbytes+1);

    /* Copy the read data into the provided read_data array */
    for (uint8_t i = 0; i < nbytes; i++) {

        read_data[i] = temp_buffer[i+1]; //the first byte is the loopback of the read command, so we drop it
    }
}


/*****************************************************************************
 * Function: gpx2_WriteByte()
 *//**
 *
 * @brief		Writes to a single register of the GPX2.
 *
 *
 * @return		Register read data, single byte (uint8_t).
 *
 * @note
 *
****************************************************************************/

void gpx2_WriteByte(uint8_t reg_addr, uint8_t write_data)
{

	uint8_t nbytes = 2U;

	/* Data to put on SPI bus */
	uint8_t tx_data[2] = {(reg_addr |= 0x80), write_data};

	/* Call AXI SPI I/F function */
	spiWriteBytes(tx_data, nbytes);

}


/*****************************************************************************
 * Function: gpx2_WriteBytesContinuously()
 *//**
 *
 * @brief		Writes to a single or multiple consecutive registers of the GPX2.
 *
 *
 * @return
 *
 * @note
 *
****************************************************************************/

void gpx2_WriteBytesContinuously(uint8_t reg_addr, uint8_t* write_data, uint8_t nbytes)
{
    /* Data to put on SPI bus */
    uint8_t tx_data[nbytes + 1];

    /* Set the first byte to the register address with the MSB set */
    tx_data[0] = reg_addr | 0x80;

    /* Copy the write_data into tx_data */
    for (uint8_t i = 0; i < nbytes; i++) {
        tx_data[i + 1] = write_data[i];
    }

    /* Call AXI SPI I/F function */
    spiWriteBytes(&tx_data, nbytes + 1);
}




/*****************************************************************************
 * Function: gpx2_ReadXYData()
 *//**
 *
 * @brief		Reads the GPX2 TDC data registers.
 *
 *
 * @return		32-bit data: Lower 16-bits = X-data = [X1] [X0]
 * 				Upper 16-bits = Y-data = [Y1] [Y0], i.e.
 * 				Y1 = [31:24], Y0 = [23:16], X1 = [15:8], X0 = [7:0]
 *
 * @note
 *
****************************************************************************/
//TODO: read results from TDC chip
uint32_t gpx2_ReadTDCData(void)
{

	//uint8_t start_addr;

	/* Set the SPI 'Read' and 'multi-byte' bits with the register value. */
	//start_addr = DATAX0_REG | 0xC0;

	/* Data to put on SPI bus */
	//uint8_t tx_data[5] = {start_addr, 0U, 0U, 0U, 0U};

	/* Pointer to the return data from SPI block */
	//uint8_t *xy_data_bytes;

	/* Set nbytes = 5U; byte 0 = start_addr, then 4 bytes to read back. */
	//xy_data_bytes =  spiReadBytes(tx_data, 5U);




	/* Format the return data into a 32-bit word:
	 * X0 = byte [1] = [7:0];
	 * X1 = byte [2] = [15:8];
	 * Y0 = byte [3] = [23:16];
	 * Y1 = byte [4] = [31:24]; 	 */
	uint32_t xy_data = 0;
	//xy_data = (uint32_t) xy_data_bytes[1]			/* X0 */
	//		| (uint32_t) (xy_data_bytes[2] << 8)	/* X1 */
	//		| (uint32_t) (xy_data_bytes[3] << 16)	/* Y0 */
	//		| (uint32_t) (xy_data_bytes[4] << 24);	/* Y1 */

	return xy_data;

}






/*****************************************************************************
 * Function: gpx2_IntrHandler()
 *//**
 *
 * @brief		Interrupt handler for PmodACL INT1.
 *
 * @details		Handles the PmodACL interrupt 1 event. All we do is set LED3
 * 				on the board. When the interrupt status is read using function
 * 				gpx2_ReadIntrStatus(), the LED will be cleared.
 *
 * @return 		None
 *
 * @note		None
 *
****************************************************************************/

void gpx2_IntrHandler(void)
{
	axiGpOutSet(LED3);
}




/****** End functions *****/

/****** End of File **********************************************************/

