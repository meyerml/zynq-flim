/******************************************************************************
 * @Title		:	GPX2 Interface
 * @Filename	:	gpx2_if.c
 * @Author		:	Derek Murray
 * @Origin Date	:	15/05/2020
 * @Version		:	1.0.0
 * @Compiler	:	arm-none-eabi-gcc
 * @Target		: 	Xilinx Zynq-7000
 * @Platform	: 	Digilent Zybo-Z7-20
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (C) 2021  Derek Murray
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
******************************************************************************/





/*****************************************************************************/
/***************************** Include Files *********************************/
/*****************************************************************************/

#include "gpx2_if.h"
#include "../global_defines.h"

/*****************************************************************************/
/************************** Constant Definitions *****************************/
/*****************************************************************************/


/*****************************************************************************/
/******************************* Typedefs ************************************/
/*****************************************************************************/



/*****************************************************************************/
/************************** Variable Declarations ****************************/
/*****************************************************************************/
uint8_t activechannels;

/****************************************************************************/
/***************** Macros (Inline Functions) Definitions ********************/
/****************************************************************************/



/*****************************************************************************/
/************************** Function Prototypes ******************************/
/*****************************************************************************/




/*---------------------------------------------------------------------------*/
/*------------------------------- FUNCTIONS ---------------------------------*/
/*---------------------------------------------------------------------------*/


/*****************************************************************************
 * Function: gpx2_Init()
 *//**
 *
 * @brief		Initialises the PmodACL accelerometer.
 *
 *
 * @details		Calls the axi_spiInit() function to initialise the
 * 				AXI SPI	block. If the AXI SPI initialisation is successful, then
 * 				configures the PmodACL with the desired values for this project.
 *
 * @return		Integer indicating result of configuration attempt.
 * 				0 = SUCCESS, 1 = FAILURE
 * @note
 *
****************************************************************************/

int gpx2_Init()
{
	//TODO: update initialization according to new hardware.
	//then switch to the new spi master.
	//detect interrupt,
	//handle spi comm and dma storage in task
	//
	// the default registers as recommended in the GPX2 data sheets example code:
	//

	//turn off lvds output for spi read and turn on blockwise fifo read



	// Extract the three least significant bytes
	uint32_t refclock_divisions = 1000000000/REFCLK_FREQUENCY;

	uint8_t reg3 = (refclock_divisions >> 0) & 0xFF;   // Least significant byte
	uint8_t reg4 = (refclock_divisions >> 8) & 0xFF;   // Middle byte
	uint8_t reg5 = (refclock_divisions >> 16) & 0x0F;  // Most significant byte of the three


	activechannels = STOP4ACTIVE | STOP3ACTIVE | STOP2ACTIVE | STOP1ACTIVE;
/*
	xil_printf("Current Settings are expecting a reference clock frequency of %d kHz.\r\n", REFCLK_FREQUENCY);
	switch (activechannels){
	case STOP1ACTIVE:
		xil_printf("Currently listening for STOP signals on channel 1\r\n");
		break;
	case STOP2ACTIVE:
		xil_printf("Currently listening for STOP signals on channel 2\r\n");
		break;
	case STOP3ACTIVE:
		xil_printf("Currently listening for STOP signals on channel 3\r\n");
		break;
	case STOP4ACTIVE:
		xil_printf("Currently listening for STOP signals on channel 4\r\n");
		break;
	}
	for (int w = 100000;w>0;w--){  //i dont know how to wait
		int x = w;
	}
*/
	//tell the spi master IP block where to read the results from
	if ((activechannels && STOP4ACTIVE) || (activechannels && STOP3ACTIVE )){
		axiGpOutSet(RESULTCHANNEL1);
	} else {
		axiGpOutClear(RESULTCHANNEL1);

	}
	if (activechannels && STOP2ACTIVE){
		axiGpOutSet(RESULTCHANNEL0);
	} else {
		axiGpOutClear(RESULTCHANNEL0);
	}



	//gpx2 configuration register 0
	uint8_t reset_index = DISABLED;
	uint8_t disable_pin = DISABLED;
	uint8_t lvds_output = LVDS_OUTPUT_ENABLED;
	uint8_t reference_clock = REFCLK_ENABLED;
	uint8_t reg0 = reset_index  |  disable_pin | lvds_output | reference_clock | activechannels;

	//gpx2 configuration register 1
	uint8_t resolution = HIGH_RESOLUTION2;
	uint8_t channel_combine = NO_COMBINE;
	uint8_t reg1 = resolution | channel_combine | activechannels;

	//gpx2 configuration register 2
	uint8_t refindex_config;
	switch (REF_INDEX_BITWIDTH){
	case 0:
		refindex_config=0b000;
		break;
	case 2:
		refindex_config=0b001;
		break;
	case 4:
		refindex_config=0b010;
		break;
	case 8:
		refindex_config=0b011;
		break;
	case 16:
		refindex_config=0b100;
		break;
	case 24:
		refindex_config=0b101;
		break;
	case 6:
		refindex_config=0b110;
		break;
	case 12:
		refindex_config=0b111;
		break;
	default:
		xil_printf("an invalid REF_INDEX_BITWIDTH of &d was selected.", REF_INDEX_BITWIDTH);
	}

	uint8_t stopdata_config;
	switch (STOP_DATA_BITWIDTH){
	case 14:
		stopdata_config=0b00;
		break;
	case 16:
		stopdata_config=0b01;
		break;
	case 18:
		stopdata_config=0b10;
		break;
	case 20:
		stopdata_config=0b11;
		break;
	default:
		xil_printf("an invalid STOP_DATA_BITWIDTH of &d was selected.", STOP_DATA_BITWIDTH);
	}

	uint8_t reg2 = 0x00; //0x1D;
	//reg3 &= 0x3F; //delete the first two bits
	uint8_t blockwise_fifo_read = BLOCKWISE_FIFO_READ_ENABLED;
	uint8_t common_fifo_read = DISABLED;
	reg2 |= blockwise_fifo_read | common_fifo_read | stopdata_config << 3 | refindex_config;

	uint8_t lvds_test_pattern = LVDS_TEST_PATTERN_ON;
	uint8_t reg6 = 0xC0 | lvds_test_pattern;

	uint8_t reg7 = 0x43 | LVDS_DATA_VALID_ADJUST;
	uint8_t GPX2_STARTUP_CONFIG[17] = {reg0, reg1, reg2, reg3, reg4, reg5, reg6, //0xC0,
			reg7, 0xA1, 0x13, 0x00, 0x0A, 0xCC, 0xCC, 0x31, 0x8E, 0x04 };	//uint8_t GPX2_STARTUP_CONFIG[17] = {0x31, 0x01, 0x1F, 0x40, 0x0D, 0x03, 0xC0,
	//		0x53, 0xA1, 0x13, 0x00, 0x0A, 0xCC, 0xCC, 0x31, 0x8E, 0x04 };
	//uint8_t GPX2_STARTUP_CONFIG[17] = {0x31, 0x01, 0x1F, 0x40, 0x0D, 0x03, 0xC0,
	//		0x53, 0xA1, 0x13, 0x00, 0x0A, 0xCC, 0xCC, 0x31, 0x8E, 0x04 };
	// 		uint8_t GPX2_STARTUP_CONFIG[17] = {0x11, 0x01, 0x9F, byte1, byte2, byte3, 0xC0,
	//0x53, 0xA1, 0x13, 0x00, 0x0A, 0xCC, 0xCC, 0x31, 0x8E, 0x04 };	//uint8_t GPX2_STARTUP_CONFIG[17] = {0x31, 0x01, 0x1F, 0x40, 0x0D, 0x03, 0xC0,

	uint8_t configReadBack[17] = {0};
	/* Set SPI options for the PMOD_ACL.
	 * Parameters can be found in xspi.h.
	uint32_t options = XSP_CLK_ACTIVE_LOW_OPTION
						| XSP_MANUAL_SSELECT_OPTION
						| XSP_CLK_PHASE_1_OPTION
						| XSP_MASTER_OPTION;
	*/
	/* Set SPI options for the GPX2 to work in SPI mode 1.
	 * Parameters can be found in xspi.h. */
	uint32_t options =  XSP_MANUAL_SSELECT_OPTION
						| XSP_CLK_PHASE_1_OPTION
						| XSP_MASTER_OPTION;

	/* Initialise the AXI SPI block */
	int status;
	status = axi_spiInit(options);


	/* If AXI SPI initialisation is successful, configure
	 * the PmodACL with desired values for this project. */
	//TODO: update with meaningful GPX2 register values
	if (status == XST_SUCCESS)
	{
		//disableInterrupts();
	    uint8_t command = POR_CMD;

		spiWriteBytes(&command,1); //restart the gpx2 device


		gpx2_WriteBytesContinuously(0x00, &GPX2_STARTUP_CONFIG ,17);

		gpx2_ReadBytesContinuously(0x00, &configReadBack,17);
		//enableInterrupts();
		for (uint8_t b = 0; b<17; b++){
			if(configReadBack[b] != GPX2_STARTUP_CONFIG[b]){
				status = XST_FAILURE;
			}
		}


		//start the gpx2 measurement by sending the start command
		command = INIT_START_CMD;
		spiWriteBytes(&command,1);
		const int MSGLEN = REF_INDEX_BITWIDTH + STOP_DATA_BITWIDTH;


		//set msglen
		if(MSGLEN&0x01){
		axiGpOutSet(MSGLEN0);
		}
		if(MSGLEN&0x02){
		axiGpOutSet(MSGLEN1);
		}
		if(MSGLEN&0x04){
		axiGpOutSet(MSGLEN2);
		}
		if(MSGLEN&0x08){
		axiGpOutSet(MSGLEN3);
		}
		if(MSGLEN&0x10){
		axiGpOutSet(MSGLEN4);
		}
		if(MSGLEN&0x20){
		axiGpOutSet(MSGLEN5);
		}

		//toggle mux towards the custom spi interface
		//axiGpOutSet(SPI_SEL_1);
		//axiSpiSelectOutSet(SPI_SELECT_1);
		/*
		gpx2_WriteByte(THRESH_TAP_REG, THRESH_TAP_VAL);
		gpx2_WriteByte(DUR_REG, DUR_VAL);
		gpx2_WriteByte(THRESH_INACT_REG, THRESH_INACT_VAL);
		gpx2_WriteByte(TIME_INACT_REG, TIME_INACT_VAL);
		gpx2_WriteByte(ACT_INACT_CTL_REG, ACT_INACT_CTL_VAL);
		gpx2_WriteByte(TAP_AXES_REG, TAP_AXES_VAL);
		gpx2_WriteByte(BW_RATE_REG, BW_RATE_VAL);
		gpx2_WriteByte(POWER_CTL_REG, POWER_CTL_VAL);
		gpx2_WriteByte(INT_ENABLE_REG, INT_ENABLE_VAL);
		gpx2_WriteByte(INT_MAP_REG, INT_MAP_VAL);
		gpx2_WriteByte(DATA_FORMAT_REG, DATA_FORMAT_VAL);
		*/
	}
	// else just end

	return status;

}



/*****************************************************************************
 * Function: gpx2_ReadByte()
 *//**
 *
 * @brief		Reads a single register of the GPX2.
 *
 * @return		Register read data, single byte (uint8_t).
 *
 * @param[in]	PmodACL register address to read from.
 *
 * @note
 *
****************************************************************************/

uint8_t gpx2_ReadByte(uint8_t reg_addr)
{

	uint8_t nbytes = 2U;
	uint8_t *read_data;

	/* Data to put on SPI bus */
	uint8_t tx_data[2] = {(reg_addr | 0x40), 0U};

	/* Set nbytes = 2U; one byte for addr, and one for return data */
	read_data =  spiReadBytes(&tx_data, nbytes);
	uint8_t read_value = read_data[1];
	/* Byte 1 is the read data */
	return read_data[1];
}


/*****************************************************************************
 * Function: gpx2_ReadBytesContinuously()
 *//**
 *
 * @brief		Reads a single or multiple consecutive registers of the GPX2.
 *
 * @return		Register read data, single byte (uint8_t).
 *
 * @param[in]	PmodACL register address to read from.
 *
 * @note
 *
****************************************************************************/

void gpx2_ReadBytesContinuously(uint8_t reg_addr, uint8_t* read_data, uint8_t nbytes)
{
    /* Data to put on SPI bus */
    uint8_t tx_data[nbytes + 1];


    /* Set the first byte to the register address with the MSB set */
    tx_data[0] = reg_addr | 0x40;

    /* Copy the write_data into tx_data */
    for (uint8_t i = 0; i < nbytes; i++) {
        tx_data[i + 1] = 0x00;
    }

    /* Read data into a temporary buffer */
    uint8_t* temp_buffer = spiReadBytes(&tx_data, nbytes+1);

    /* Copy the read data into the provided read_data array */
    for (uint8_t i = 0; i < nbytes; i++) {

        read_data[i] = temp_buffer[i+1]; //the first byte is the loopback of the read command, so we drop it
    }
}


/*****************************************************************************
 * Function: gpx2_WriteByte()
 *//**
 *
 * @brief		Writes to a single register of the GPX2.
 *
 *
 * @return		Register read data, single byte (uint8_t).
 *
 * @note
 *
****************************************************************************/

void gpx2_WriteByte(uint8_t reg_addr, uint8_t write_data)
{

	uint8_t nbytes = 2U;

	/* Data to put on SPI bus */
	uint8_t tx_data[2] = {(reg_addr |= 0x80), write_data};

	/* Call AXI SPI I/F function */
	spiWriteBytes(tx_data, nbytes);

}


/*****************************************************************************
 * Function: gpx2_WriteBytesContinuously()
 *//**
 *
 * @brief		Writes to a single or multiple consecutive registers of the GPX2.
 *
 *
 * @return
 *
 * @note
 *
****************************************************************************/

void gpx2_WriteBytesContinuously(uint8_t reg_addr, uint8_t* write_data, uint8_t nbytes)
{
    /* Data to put on SPI bus */
    uint8_t tx_data[nbytes + 1];

    /* Set the first byte to the register address with the MSB set */
    tx_data[0] = reg_addr | 0x80;

    /* Copy the write_data into tx_data */
    for (uint8_t i = 0; i < nbytes; i++) {
        tx_data[i + 1] = write_data[i];
    }

    /* Call AXI SPI I/F function */
    spiWriteBytes(&tx_data, nbytes + 1);
}




/*****************************************************************************
 * Function: gpx2_ReadXYData()
 *//**
 *
 * @brief		Reads the GPX2 TDC data registers.
 *
 *
 * @return		32-bit data: Lower 16-bits = X-data = [X1] [X0]
 * 				Upper 16-bits = Y-data = [Y1] [Y0], i.e.
 * 				Y1 = [31:24], Y0 = [23:16], X1 = [15:8], X0 = [7:0]
 *
 * @note
 *
****************************************************************************/
//TODO: read results from TDC chip
uint32_t gpx2_ReadTDCData(void)
{

	//uint8_t start_addr;

	/* Set the SPI 'Read' and 'multi-byte' bits with the register value. */
	//start_addr = DATAX0_REG | 0xC0;

	/* Data to put on SPI bus */
	//uint8_t tx_data[5] = {start_addr, 0U, 0U, 0U, 0U};

	/* Pointer to the return data from SPI block */
	//uint8_t *xy_data_bytes;

	/* Set nbytes = 5U; byte 0 = start_addr, then 4 bytes to read back. */
	//xy_data_bytes =  spiReadBytes(tx_data, 5U);




	/* Format the return data into a 32-bit word:
	 * X0 = byte [1] = [7:0];
	 * X1 = byte [2] = [15:8];
	 * Y0 = byte [3] = [23:16];
	 * Y1 = byte [4] = [31:24]; 	 */
	uint32_t xy_data = 0;
	//xy_data = (uint32_t) xy_data_bytes[1]			/* X0 */
	//		| (uint32_t) (xy_data_bytes[2] << 8)	/* X1 */
	//		| (uint32_t) (xy_data_bytes[3] << 16)	/* Y0 */
	//		| (uint32_t) (xy_data_bytes[4] << 24);	/* Y1 */

	return xy_data;

}






/*****************************************************************************
 * Function: gpx2_IntrHandler()
 *//**
 *
 * @brief		Interrupt handler for PmodACL INT1.
 *
 * @details		Handles the PmodACL interrupt 1 event. All we do is set LED3
 * 				on the board. When the interrupt status is read using function
 * 				gpx2_ReadIntrStatus(), the LED will be cleared.
 *
 * @return 		None
 *
 * @note		None
 *
****************************************************************************/

void gpx2_IntrHandler(void)
{
	axiGpOutSet(LED3);
}




/****** End functions *****/

/****** End of File **********************************************************/

