/******************************************************************************
 * @Title		:	Zynq Fundamentals Software Project 9
 * @Filename	:	sw_proj9_main.c
 * @Author		:	Derek Murray
 * @Origin Date	:	15/05/2020
 * @Version		:	1.0.0
 * @Compiler	:	arm-none-eabi-gcc
 * @Target		: 	Xilinx Zynq-7000
 * @Platform	: 	Digilent Zybo-Z7-20
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (C) 2021  Derek Murray
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
******************************************************************************/



/*****************************************************************************/
/***************************** Include Files *********************************/
/*****************************************************************************/

#include "main.h"
#include "global_defines.h"
#include "report.h"
#include <stdalign.h>
#include "dma/dma.h"
// Declare the global array using uint32_t or u32 if properly defined
alignas(16) uint32_t global_destination[DESTINATIONLENGTH];
long int timer_counter = 0;

//#define FRAMESIZE 16
//#define DATA_WIDTH_IN_BYTES 4

int main(void){


	// ********************************************************************************* //
	// *****  INITIALIZATION PHASE *****
	// ********************************************************************************* //

#if MAIN_DEBUG
	printf("\n\r------------------------------------------------------------\n\r");
	printf("----------- GPX2_LVDS_READOUT -----------\n\r");
	printf("------------------------------------------------------------\n\r");
	//printf("Architecture: FG/BG Polled State Machine.\r\n");
	//printf("Timing: Triple Timer Counter 0, Wave 0.\r\n\r\n");
#endif


	/* ----------------------------------------
	 * SYSTEM INITIALISATION (drivers, etc)
	 * ----------------------------------------
	 * If initialisation is successful, LED0 is turned on to indicate that the system
	 * is ready. If initialisation is not successful, then LED0 will flash, and the
	 * program will not continue to the main phase.
	 */

	/* Variable for initialisation status */
	int init_status;



	/* Run initialisation */
	init_status = sys_init();

	if (init_status == XST_SUCCESS){
		#if MAIN_DEBUG
			printf("\n\rSystem ready.\n\r");
		#endif
	}
	else {
		#if MAIN_DEBUG
			printf("\n\r!!! INITIALIZATION FAILED !!!\n\r");
		#endif
		while(1) { // Stay in this loop

		//restartScuWdt();

		uint32_t delay = 0U;
		for (delay = 0; delay < INIT_FAIL_LOOP_DELAY; delay++)
			{}
		}
	}


	// ********************************************************************************* //
	// *****   MAIN PROGRAM [TASK STATE MACHINE ARCHITECTURE] *****
	// ********************************************************************************* //

#if MAIN_DEBUG
	printf("\n\rRunning main program; LED4 should be toggling.\n\r");
	//IMPORTANT:REFCLK_DIVISIONS should be set to the picosecond value of the refence clock. that
	//float REFCLK_FREQUENCY = 1000000.0/REFCLK_DIVISIONS;

    //int whole, thousandths;
    //whole = REFCLK_FREQUENCY;
    //thousandths = (REFCLK_FREQUENCY - whole) * 1000;
    //xil_printf("%d.%3d\n", whole, thousandths);

	xil_printf("Current Settings are expecting a reference clock frequency of %d kHz.\r\n", REFCLK_FREQUENCY);
		switch (activechannels){
		case STOP1ACTIVE:
			xil_printf("Currently listening for STOP signals on channel 1\r\n");
			break;
		case STOP2ACTIVE:
			xil_printf("Currently listening for STOP signals on channel 2\r\n");
			break;
		case STOP3ACTIVE:
			xil_printf("Currently listening for STOP signals on channel 3\r\n");
			break;
		case STOP4ACTIVE:
			xil_printf("Currently listening for STOP signals on channel 4\r\n");
			break;
		}
		xil_printf("gathering %d samples.\r\n", NUMSAMPLES);

#endif


	//dynamically allocate some ram for the dma to save the data to
	// the actual DMA instruction.
	//volatile u32 *destination = (u32 *)malloc(8 * 32);
//    // Directly assign values to the allocated memory
//    destination[0] = 0xDEADC0DE;
//    destination[1] = 0xDEADC0DE;
//    destination[2] = 0xDEADC0DE;
//    destination[3] = 0xDEADC0DE;
//    destination[4] = 0xDEADC0DE;
//    destination[5] = 0xDEADC0DE;
//    destination[6] = 0xDEADC0DE;
//    destination[7] = 0xDEADC0DE;



	clear_ram_section((void*)global_destination, DESTINATIONLENGTH); //write DEADC0DE all over the receive buffer

		/* Flush the buffers before the DMA transfer, in case the Data Cache
		 * is enabled
		 */
		//Xil_DCacheFlushRange((UINTPTR)destination, MAX_PKT_LEN);
	Xil_DCacheFlushRange((UINTPTR)global_destination, DESTINATIONLENGTH);
	Xil_DCacheInvalidateRange((UINTPTR)global_destination, DESTINATIONLENGTH);

	/* Set up RX channel to be ready to transmit and receive packets */
	int Status = RxSetup(&global_destination);
	if (Status != XST_SUCCESS) {

		xil_printf("Failed RX setup\r\n");
		return XST_FAILURE;
	}


	//int DMAstatus = DMAStart(global_destination, MAX_PKT_LEN);
	axiGpOutSet(LVDS_START);  //the DMA is already waiting, so start the LVDS engine

	//int DMAstatus = DMAStart(global_destination, DESTINATION_LENGTH);

	//axiGpOutSet(LVDS_En); //actually not used right now


	/*
	 * Check for any error events to occur.
	 * Upon error, check the error path (Tx/Rx)
	 */
	//int Status;
	Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &Error);
	if (Status == XST_SUCCESS) {
		if (!RxDone) {
			xil_printf("Receive error %d\r\n", Status);
		}
	}
	Xil_DCacheInvalidateRange((UINTPTR)global_destination, DESTINATIONLENGTH);

	/*
	 * Wait for RX done to be received for all the BDs or timeout
	 *
	 * the RxDone signal is set in the interrupt handler
	 */
	Status = Xil_WaitForEventSet(RX_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &RxDone);
	if (Status != XST_SUCCESS) {
		xil_printf("Receive failure\r\n");
	}

	/*
	 * Test finished, write out data
	 */
	Status = ReportData(global_destination, PRINT_REFINDICES, PRINT_STOPRESULTS, PRINT_STATISTICS);
	if (Status != XST_SUCCESS) {
		xil_printf("Reporting Data failed\r\n");
	}


	while(1){
		//we should not get past this point.
	}

	return 0;
}


/****** End main()  *****/

/****** End of File **********************************************************/
